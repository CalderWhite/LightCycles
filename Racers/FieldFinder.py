from LightCycles.Racer import Racer


class FieldFinder(Racer):
    direction = (0, 1)
    directions = [
        (0, 1),
        (1, 0),
        (0, -1),
        (-1, 0)
    ]

    def __init__(self, start_row, start_col, grid_width, use_dist=False):
        super().__init__(start_row, start_col, grid_width)
        self.use_dist = use_dist

    @staticmethod
    def dist_squared(x1, y1,  x2, y2):
        x = x1-x2
        y = y1-y2
        return x*x + y*y

    def get_dir_dists_sqrd(self, pos, _map):
        """Return all the distance to the closest wall/light trail in all directions."""
        gw = self.grid_width
        r, c = pos

        dirs = self.directions.copy()
        # never consider going backwards
        pos = [(r, c)]*4

        dist = []
        good_bois = []
        good_pos = []
        while len(dirs) > 0:
            for i in range(len(dirs)-1, -1, -1):
                nr, nc = pos[i]
                nr += dirs[i][0]
                nc += dirs[i][1]

                if nr >= gw or nr < 0 or nc >= gw or nc < 0 or _map[nr][nc]:
                    good_bois.append(dirs[i])
                    # append the position instead of the new one, since the new one
                    # gets you killed
                    good_pos.append(pos[i])
                    dirs.pop(i)
                    pos.pop(i)
                    d = self.dist_squared(r, c, nr, nc)
                    dist.append(d)
                else:
                    pos[i] = (nr, nc)

        return dist, good_bois, good_pos

    def get_area(self, _dir, _pos, _map):
        """Get the area created by going a particular direction from the current position."""
        _ds, _dr, _ps = self.get_dir_dists_sqrd(_pos, _map)

        # do not consider going backwards
        # otherwise the area would be deceptively large
        _dir_inv = (-_dir[0], -_dir[1])
        _dir_inv_i = _dr.index(_dir_inv)
        _ds.pop(_dir_inv_i)
        _dr.pop(_dir_inv_i)
        _ps.pop(_dir_inv_i)

        fwd_i = _dr.index(_dir)
        _dr.pop(fwd_i)
        _ps.pop(fwd_i)

        # this has no matching pair as backwards is not feasible
        fwd_dist = _ds.pop(fwd_i)

        # the remaining distances create the perpendicular width
        side_dist = sum(_ds)

        return fwd_dist * side_dist

    def get_areas(self, dir, dirs, positions, _map):
        """Find the areas generated by taking each direction."""
        # do not consider going backwards
        dir_inv = (-dir[0], -dir[1])
        dir_inv_i = dirs.index(dir_inv)
        dirs.pop(dir_inv_i)
        positions.pop(dir_inv_i)

        good_dirs = []
        areas = []
        good_pos = []

        for i in range(len(dirs)):
            _dir = dirs[i]
            _pos = positions[i]
            area = self.get_area(_dir, _pos, _map)
            areas.append(area)
            good_dirs.append(_dir)
            good_pos.append(_pos)

        return areas, good_dirs, good_pos

    def get_next_move(self, racer_positions, _map):
        dists, dirs, positions = self.get_dir_dists_sqrd(self.get_pos(), _map)

        if len(dirs) < 1:
            return (0, 0)

        # dist based choice
        if self.use_dist:
            choice = dirs[dists.index(max(dists))]
            self.direction = choice
            return choice

        # this is sort of funky, but it's okay.
        # it looks down a path and then looks at how wide the path is
        # however, due to the nature of the area function the closer the position
        # being looked at is to your current the position, the higher it is weighted.
        # in a sense, this can make sense since predicting too far in the future can be dangerous
        # however, this weighting is still something that is not very explicit but is
        # going on under the hood and should be mentioned for this reason

        areas = [0] * len(dirs)
        for i in range(len(dirs)):
            dr, dc = dirs[i]
            endpos = positions[i]
            r, c = self.get_pos()

            dst_r = abs(endpos[0] - r)
            dst_c = abs(endpos[1] - c)

            # the higher this number, the faster the bot will compute but the stupider the bot will be
            step = 4

            # this is what your bots seeing distance is multiplied by
            sight_factor = 1
            if dst_r != 0:
                for j in range(0, dst_r*sight_factor, step):
                    r += dr*step
                    area = self.get_area((dr, dc), (r, c), _map)
                    areas[i] += area
            else:
                for j in range(0, dst_c*sight_factor, step):
                    c += dc*step
                    area = self.get_area((dr, dc), (r, c), _map)
                    areas[i] += area


        ### old method ###
        #areas, good_dirs, good_pos = self.get_areas(dir, dirs, positions, _map)

        if len(areas) < 1:
            return (0, 0)

        # in order to compare the dist squared and area, you would think
        # normalization would take place to place them each between 0 and 1
        # 0 worst, 1 best. However, the max dist squared is also the max area
        # thus, the dist squared can fairly be compared to the area
        choice = (0, 0)

        """
        if max(dists)*0.01 > max(areas):
            choice = dirs[dists.index(max(dists))]
            print("dist choice:", choice)
        else:
            choice = good_dirs[areas.index(max(areas))]
        """

        ### end old method ###

        choice = dirs[areas.index(max(areas))]

        self.direction = choice
        return choice
